#!/sbin/runscript
# Copyright 2007 Roy Marples
# All rights reserved

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

description="Loads a user defined list of kernel modules."

depend() {
	need checkroot
	use isapnp
}

_shell_var() {
	local rem=$1 c= r= var=
	while [ -n "${rem}" ]; do
		r=${rem#?}
		c=${rem%${r}}
		case "${c}" in
			[a-zA-Z0-9]);;
			*) c=_;;
		esac
		var=${var}${c}
		rem=${r}
	done
	echo ${var}
}

start() {
	# Should not fail if kernel do not have module
	# support compiled in ...
	[ ! -f /proc/modules -o "${RC_SYS}" = "VPS" ] && return 0

	local KV=$(uname -r)
	local KV_MAJOR=${KV%%.*}
	local x=${KV#*.}
	local KV_MINOR=${x%%.*}
	x=${KV#*.*.}
	local KV_MICRO=${x%%-*}

	local list= x= opts= cnt=0
	for x in "${KV}" ${KV_MAJOR}.${KV_MINOR}.${KV_MICRO} ${KV_MAJOR}.${KV_MINOR}; do
		eval list=\$modules_$(_shell_var "${x}")
		[ -n "${list}" ] && break
	done
	[ -z "${list}" ] && list=${modules}

	for x in ${list}; do
		ebegin "Loading module ${x}"
		eval opts=\$module_$(_shell_var "${x}")_opts
		eval modprobe -q "${x}" "${opts}"
		eend $? "Failed to load ${x}" && cnt=$((${cnt} + 1))
	done
	einfo "Autoloaded ${cnt} module(s)"

	# Just in case a sysadmin prefers generic symbolic links in
	# /lib/modules/boot for boot time modules we will load these modules
	[ -n "$(modprobe -l -t boot)" ] && modprobe -a -t boot \* 2>/dev/null
	
	# Above test clobbers the return
	return 0
}

# vim: set ts=4 :
