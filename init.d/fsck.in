#!@PREFIX@/sbin/runscript
# Copyright (c) 2007-2009 Roy Marples <roy@marples.name>
# All rights reserved. Released under the 2-clause BSD license.

description="Check and repair filesystems according to /etc/fstab"
_IFS="
"

depend()
{
	use dev clock modules
	keyword -jail -openvz -prefix -timeout -vserver
}

_abort() {
	rc-abort
	return 1
}

# We should only reboot when first booting
_reboot() {
	if [ "$RC_RUNLEVEL" = "$RC_BOOTLEVEL" ]; then
		reboot "$@"
		_abort || return 1
	fi
}

_forcefsck()
{
	[ -e /forcefsck ] || get_bootparam forcefsck
}

_on_ac_power()
{
	if [ -f /proc/acpi/ac_adapter/AC*/state ]; then
		cat /proc/acpi/ac_adapter/AC*/state | while read line; do
			case "$line" in
			"state:"*"off-line") return 128;;
			esac
		done
	elif [ -f /proc/pmu/info ]; then
		cat /proc/pmu/info | while read line; do
			case "$line" in
			"AC Power"*": 0") return 128;;
			esac
		done
	elif type envstat >/dev/null 2>&1; then
		# NetBSD has envstat
		envstat -d acpiacad0 2>/dev/null | while read line; do
			case "$line" in
			"connected:"*"OFF") return 128;;
			esac
		done
	elif sysctl -q hw.acpi.acline >/dev/null 2>/dev/null; then
		case $(sysctl -n hw.acpi.acline) in
		0) return 1;;
		*) return 0;;
		esac
	else
		return 0
	fi
	[ $? != 128 ]
}

start()
{
	local fsck_opts= p= check_extra=

	if [ -e /fastboot ]; then
		ewarn "Skipping fsck due to /fastboot"
		return 0
	fi
	if _forcefsck; then
		fsck_opts="$fsck_opts -f"
		check_extra="(check forced)"
	elif ! _on_ac_power; then
		ewarn "Skipping fsck due to not being on AC power"
		return 0
	fi

	if [ -n "$fsck_passno" ]; then
		check_extra="[passno $fsck_passno] $check_extra"
	fi
	ebegin "Checking local filesystems $check_extra"
	for p in $fsck_passno; do
		local IFS="$_IFS"
		case "$p" in
			[0-9]*) p="=$p";;
		esac
		set -- "$@" $(fstabinfo --passno "$p")
		unset IFS
	done

	if [ "$RC_UNAME" = Linux ]; then
		fsck_opts="$fsck_opts -C0 -T"
		if [ -z "$fsck_passno" ]; then
			fsck_args=${fsck_args--A -p}
			if echo 2>/dev/null >/.test.$$; then
				rm -f /.test.$$
				fsck_opts="$fsck_opts -R"
			fi
		fi
	fi

	trap : INT QUIT
	fsck ${fsck_args--p} $fsck_opts "$@"
	case $? in
	0)	eend 0; return 0;;
	1)	ewend 1 "Filesystems repaired"; return 0;;
	2|3)	if [ "$RC_UNAME" = Linux ]; then
		 	ewend 1 "Filesystems repaired, but reboot needed"
	         	_reboot -f
		else
			ewend 1 "Filesystems still have errors;" \
				"manual fsck required"
			_abort
		fi;;
	4)	if [ "$RC_UNAME" = Linux ]; then
			ewend 1 "Fileystem errors left uncorrected, aborting"
			_abort
		else
		 	ewend 1 "Filesystems repaired, but reboot needed"
			_reboot
		fi;;
	8)	ewend 1 "Operational error"; return 0;;
	12)	ewend 1 "fsck interupted";;
	*)	eend 2 "Filesystems couldn't be fixed";;
	esac
	_abort || return 1
}

stop()
{
	# Fake function so we always shutdown correctly.
	_abort() { return 0; }
	_reboot() { return 0; }
	_forcefsck() { return 1; }

	yesno $fsck_shutdown && start
	return 0
}
